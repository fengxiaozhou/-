面试题
操作系统
1.线程和进程的区别 	
    进程：并发执行的程序在执行过程中分配和管理资源的基本单位.进程的执行过程是线性的，进程的切换保护资源。 
    线程： 是CPU调度的基本单位 线程共享进程中的资源，线程的切换并不影响计算机软硬件资源的分配。
2.中断和异常的区别
    中断：系统停止当前正在运行的程序而转向其他服务 
    异常：软件运行过程中的一种开发过程中没有考虑到的程序错误也称为同步中断，在指令执行结束后发生的中断 
3.虚拟内存和虚拟地址
	虚拟内存: 程序使用的内存，利用外存来扩充内存，需要内存映射 
	虚拟地址：由页号和偏移量组成，位数与地址总线的位数相同 
4.死锁
   必要条件： 
   （1）互斥条件：一个资源每次只能被一个进程使用 
   （2）请求与保持条件：进程因请求资源而阻塞时，对获得的资源保持不放 
   （3）不剥夺条件：已获得资源，未使用完之前不能被剥夺 
   （4）循环等待条件： 
   解决方法： 
   （1）死锁预防：破坏死锁产生的条件 
   （2）死锁避免：每次申请之前判断是否安全（银行家算法） 
   （3）死锁检测：（超时法和等待图法） 
   （4）死锁解除
5.多进程和多线程 
    前者开销大，后者开销小（数据，资源角度），前者更加独立。 
6.页面置换算法 FIFO，LRU,LFU
    OPT:选择在内存中离下次访问时间最长的页面，将其置换
    FIFO：链表形式存储，先进先出，Belady现象(有时会出现分配的物理页面数增加，缺页率反而提高的异常现象)。
    LRU(Least Recently Used)：最近最久没有使用，LRU算法需要记录各个页面使用时间的先后顺序，开销较大。
           如果内存当中的所有页面都未曾访问过，那么LRU算法就退化为FIFO算法。
    LFU(Least Frequently Used：最不常用算法。
        LRU考察的是多久未访问，时间越短越好；而LFU考察的是访问的次数或频率，访问次数越多越好。
7.抖动问题
    刚被置换出的页面马上又被使用。随着驻留内存的进程数目增加，分配给每个进程的物理页面数不断减小，缺页率不断上升，系统中多道程序度过高，进程运行缺页率严重。
8.缺页中断 
    访问的页不在主存，需要操作系统将其调入主存后再进行访问。
9.进程间通信的方式
    管道
       普通管道：半双工,只能单向传输;只能在父子进程间使用
       命名管道：可以在许多并不相关的进程之间进行通讯
       流式管道：可以双向传输
    消息队列
        消息队列是由消息的链表，存放在内核中并由消息队列标识符标识 
        消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点
    信号量  
        信号量是一个计数器，常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段
    socket  
        可以在不同机器之间进行通信
    共享内存
        映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问
    信号
10.线程间的通信方式
    临界区
    事件
    互斥量
    信号量
11.线程状态，具体怎么运行的
    新建(new)         新创建了一个线程对象。
    可运行(runnable)  可运行线程池中，等待被线程调度选中，获取cpu 的使用权。
    运行(running)     可运行状态(runnable)的线程获得了cpu 时间片（timeslice） ，执行程序代码。
    阻塞(block)       指线程因为某种原因放弃了cpu 使用权,暂时停止运行,直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice 
                      转到运行(running)状态。
                      有三种阻塞：等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。
                                  同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(
                                            lock pool)中。
                                  其他阻塞：运行(running)的线程执行Thread.sleep或t.join方法，或者发出了I/O请求时，JVM会把该线程置
                                            为阻塞状态。
    死亡(dead)：      线程run()、main() 方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。
    
算法
1.10亿个数找10个频率最高的（top K问题）
2.1001里两个重复的数字（重复数字问题）
3.二叉树层次遍历（如何只遍历某一层）
4.链表反转   
5.二叉树遍历，递归和非递归
6.常用排序算法（复杂度，稳定性）
7.找出数组中最大的连续和 (动态规划)
8.合并两个有序链表
9.快速排序算法（手写） 递归&非递归
10.2sum和ksum问题 
11.蓄水池问题
12.实现大数相乘
13.重建二叉树
14.字符串全排列
15.0，1背包
16.找最长回文
17.层次打印二叉树


java基础
1.JUC(java并发包,包括：Atomic，Locks，Collections，Executor,Tools)
     AQS(AbstractQueuedSynchronizer) 
     AQS是独占锁(例如，ReentrantLock)和共享锁(例如，Semaphore)的公共父类。
          独占锁 锁在一个时间点只能被一个线程锁占有  
                 公平锁     通过CLH等待线程按照先来先得的规则，公平的获取锁（CLH队列是AQS中“等待锁”的线程队列）
                 非公平锁   它会无视CLH等待队列而直接获取锁
          共享锁 能被多个线程同时拥有，能被共享的锁
     CAS函数，是比较并交换函数，它是原子操作函数；即，通过CAS操作的数据都是以原子方式进行的
     ReentrantLock与sync是组合关系。ReentrantLock中，包含了Sync对象,ReentrantLock是一个独占锁，至于它到底是公平锁还是非公平锁，就取决于sync对象是"FairSync的实例"还是"NonFairSync的实例"。
     公平锁在运行时直接Acquire(1),非公平锁先尝试通过CAS去获取一下锁，不行则进入Acquire(1);
     
2.volitile关键字，内存屏障和重排序
    JVM内存模型：主内存和线程独立的工作内存
    工作内存中保存了主内存共享变量的副本，线程要操作这些共享变量，只能通过操作工作内存中的副本来实现，操作完毕之后再同步回到主内存当中。
    即其他线程的本地内存中的变量已经是过时的，并不是更新后的值。

3.分布式session三种实现方式和优缺点
    1. Session Replication 方式管理 (即session复制)
        简介：将一台机器上的Session数据广播复制到集群中其余机器上
        使用场景：机器较少，网络流量较小
        优点：实现简单、配置较少、当网络中有机器Down掉时不影响用户访问
        缺点：广播式复制到其余机器有一定廷时，带来一定网络开销
    2.Session Sticky 方式管理
        简介：即粘性Session、当用户访问集群中某台机器后，强制指定后续所有请求均落到此机器上
        使用场景：机器数适中、对稳定性要求不是非常苛刻
        优点：实现简单、配置方便、没有额外网络开销
        缺点：网络中有机器Down掉时、用户Session会丢失、容易造成单点故障
    3. 缓存集中式管理
       简介：将Session存入分布式缓存集群中的某台机器上，当用户访问不同节点时先从缓存中拿Session信息
       使用场景：集群中机器数多、网络环境复杂
       优点：可靠性好
       缺点：实现复杂、稳定性依赖于缓存的稳定性、Session信息放入缓存时要有合理的策略写入

4.jvm基本调优参数
    堆设置
	-Xms:初始堆大小
	-Xmx:最大堆大小
	-XX:Xmn:设置年轻代大小
	-XX:NewRatio=n:设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4
	-XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5
	-XX:MaxPermSize=n:设置持久代大小
	-Xss:栈大小
	收集器设置
    -XX:+UseSerialGC:设置串行收集器
    -XX:+UseParallelGC:设置并行收集器
    -XX:+UseParalledlOldGC:设置并行年老代收集器
    -XX:+UseConcMarkSweepGC:设置并发收集器
    垃圾回收统计信息
    -XX:+PrintGC
    -XX:+PrintGCDetails
    -XX:+PrintGCTimeStamps
    并行收集器设置
    -XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数。
    -XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间
    -XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)
    并发收集器设置
    -XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。
    -XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。
    通常情况下  -Xms和-Xmx设置成一样的 是因为当Heap不够用时，会发生内存抖动，影响程序运行稳定性。

6.GC，垃圾回收算法
      垃圾回收可以有效的防止内存泄露，有效的使用空闲的内存
          (1.发现无用信息对象  2.回收被无用对象占用的内存空间，使该空间可被程序再次使用。)
      Java堆是进行垃圾回收的主要区域
      哪些内存需要回收：
           1.引用计数法 
              是通过判断对象的引用数量来决定对象是否可以被回收，引用计数为0的对象实例可以被当作垃圾收集。无法解决互相引用的问题。
           2.可达性分析法 
              通过判断对象的引用链是否可达来决定对象是否可以被回收。
              可作为 GC Root 的对象：虚拟机栈中引用的对象、本地方法栈中引用的对象、方法区中静态属性的引用对象、常量引用对象
      垃圾回收算法的优化就是为了减少Stop-the-World的停顿时间，从而使系统具有 高吞吐 、低停顿 的特点。
                        Java 的内存泄露表现为一个内存对象的生命周期超出了程序需要它的时间长度。
6.gc怎么回收：
      经典gc算法
          标记清除：标记和清除两个过程的效率都不高；处理大对象的时候可能无法找到连续的内存空间，空间碎片较多。
          标记整理：先标记，然后将存活的对象都向一端移动，清理掉边界之外的内存。适合存活率高的场景(老年代)。
          复制：可用内存按容量划分为大小相等的两块，每次只使用其中的一块，当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，       然后再把已使用过的内存空间一次清理掉。新生代的回收算法。Eden和Survivor的大小比例是 8:1。
      分代收集：
          不同的对象的存活情况是不一样的，而不同生命周期的对象位于堆中不同的区域，因此对堆内存不同区域采用不同的策略进行回收可以提高 JVM 的执行效率。
          当survivor1区也不足以存放eden区和survivor0区的存活对象时，就将存活对象直接存放到老年代。
          如果老年代也满了，就会触发一次FullGC，也就是新生代、老年代都进行回收。注意，新生代发生的GC也叫做MinorGC，MinorGC发生频率比较高。
          在新生代中经历了N次垃圾回收后仍然存活的对象就会被放到老年代中。
          永久代主要用于存放静态文件，如Java类、方法等。
          Full GC用于老年代和新生代
      7种垃圾回收器：
          Serial收集器（复制算法): 
                新生代单线程收集器，标记和清理都是单线程，优点是简单高效；
		  Serial Old收集器 (标记-整理算法): 
		        老年代单线程收集器，Serial收集器的老年代版本；
		  ParNew收集器 (复制算法): 
		        新生代收并行集器，实际上是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现；
	      Parallel Scavenge收集器 (复制算法): 
	            新生代并行收集器，追求高吞吐量，高效利用 CPU。吞吐量 = 用户线程时间/(用户线程时间+GC线程时间)，高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景；
		  Parallel Old收集器 (标记-整理算法)： 
		        老年代并行收集器，吞吐量优先，Parallel Scavenge收集器的老年代版本；
          CMS(Concurrent Mark Sweep)收集器（标记-清除算法）：
                老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间。
                这里需要一个新生代的收集器配合(年轻代回收依赖ParNew去回收,需要STW)
                有两次停顿，第一次是初始标记(标记GC开始时的root对象)，第二次是重新标记(在第一次标记之后程序又产生了新的存活对象)
                CMS无法处理并发清理时产生的垃圾
          G1(Garbage First)收集器 (标记-整理算法)：
                 Java堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。
                 G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代。
                 G1将内存分成多个等大小的region，在回收的时候可以选择那些具有最大回收价值的region(G1可以设定每次GC的时间)，具有停顿预测模型，在后台维护一个优先列表。
                 Region之间的对象引用是通过每个Region维护一个Remembered Set来避免全堆扫描。
                 1.初始标记(停顿)  确定GC ROOT
                 2.并发标记(可达性分析) 
                 3.修正并发标记期间因为并发而导致的标记产生变化的记录   通过Remember Set Logs去记录并且和之前的Remember Set去合并
                   (需要停顿，但是多个Remember Set可以并行执行)
                 4.筛选回收  通过每个Region的优先级排序和目标需求去筛选回收

7.什么时候垃圾回收
      垃圾回收的目的是识别并且丢弃应用不再使用的对象来释放和重用资源。
      YGC的时机: eden空间不足。对新生代堆进行GC。频率比较高，因为大部分对象的存活寿命较短，在新生代里被回收。性能耗费较小。
      FGC的时机：old空间不足，和perm的空间不足，调用system.gc()这几个都比较显而易见，就是在这种情况下，一般都会触发GC。
                 悲观策略：从新生代，通过ygc变成旧生代的平均大小，然后如果旧生代剩余的空间小于晋升大小，那么就会触发一次FullGC。
                           判断下次晋升空间够不够。
8.hashcode和equals的联系
9.JVM中的直接引用和符号引用
      解析阶段即是虚拟机将常量池内的符号引用替换为直接引用
      符号引用:无歧义的定位到目标  CONSTANT_Class_info常量的表示
      直接引用：1.直接指向目标的指针 2.相对偏移量 3.一个能间接定位到目标的句柄
10.JVM类加载过程
      加载、验证、准备、解析、初始化、使用和卸载7个阶段
11.Java基本数据类型，及占用的空间
12.泛型，定义成员方法和静态方法，接收泛型的参数
13.可检查异常和不可检查异常
14.解决Hash冲突的几种方法
      1.开放地址发  冲突之后向后找一个空的槽位添加
      2.拉链法
      3.再散列      当发生冲突时，使用第二个、第三个、哈希函数计算地址，直到无冲突时。
15.java动态代理与静态代理
16.Spring，ioc，aop
      Spring 默认是单例的  
             ioc有三种方式：1.构造器注入   在类中实现构造函数              <property name="userDao" ref="userDaoMyBatis"></property>
                            2.setter注入   在类中实现setter/getter方法     <constructor-arg name="userDao" ref="userDaoJdbc"></constructor-arg>
                                           如果通过set方法注入属性，那么spring会通过默认的空参构造方法来实例化对象，所以如果在类中写了一个带有参数的构造方法，一定要把空参数的构造方法写上，否则spring没有办法实例化对象，导致报错
                            3.注解注入     Spring的bean有一个autowire的属性，可以实现自动注入
             最初会先解析xml文件，或者扫描自动装配的类，将其放入容器  在单例和非延迟加载的时候会去直接加单xml中的bean  若是延迟加载则在使用时将其初始化
      ApplicationContext和beanfactory区别 
             beanfactory：spring中比较原始的Factory，如XMLBeanFactory就是一种典型的BeanFactory。原始的BeanFactory无法支持spring的许多插             件，如AOP功能、Web应用等。
             ApplicationContext：它由BeanFactory接口派生而来，因而提供BeanFactory所有的功能。
17.Java向上转型和向下转型
18.线程池的拒绝策略
      AbortPolicy         -- 当任务添加到线程池中被拒绝时，它将抛出 RejectedExecutionException 异常。
	  CallerRunsPolicy    -- 当任务添加到线程池中被拒绝时，会在线程池当前正在运行的Thread线程池中处理被拒绝的任务。
	  DiscardOldestPolicy -- 当任务添加到线程池中被拒绝时，线程池会放弃等待队列中最旧的未处理任务，然后将被拒绝的任务添加到等待队列中。
	  DiscardPolicy       -- 当任务添加到线程池中被拒绝时，线程池将丢弃被拒绝的任务。
	  默认的处理策略是  AbortPolicy
	  以上的策略都实现了RejectedExecutionHandler接口，通过该接口可以自定义拒绝策略
19.线程池参数，执行过程
      corePoolSize：核心线程数 会一直存活  设置allowCoreThreadTimeout=true（默认false）时，核心线程会超时关闭
      maxPoolSize： 最大线程数
      keepAliveTime：线程空闲时间，超过空闲时间可以把核心线程数以外的线程杀死
      unit：等待时间的单位
      workQueue：任务队列，被提交但尚未执行的任务。阻塞队列
      threadFactory:线程工厂，用于创建线程。
      handler：拒绝策略。
      当核心线程池未满时，创建新的线程(即使有空闲的线程)。核心池满的时候，加入等待队列。等待队列满时，创建新的线程。当线程数=maxPoolSiz
      e，且任务队列已满时，线程池会拒绝处理任务而抛出异常。
20.线程池队列的类型和线程池的种类
    线程池队列  
      直接提交队列：SynchronousQueue  没有容量  提交一个执行一个。因此需要很大的maxPoolSize，不然容易执行拒绝策略
      有界队列：ArrayBlockingQueue    参数为最大容量。   FIFO
      无界队列：LinkedBlockingQueue   会一直进入等待队列  线程数不会再增加了(没有外包员工)  FIFO
      优先任务队列：PriorityBlockingQueue   优先级先后顺序
      线程数量不能过多，CPU的时间就花在线程切换上了，真正运行代码的时间就少了，结果导致性能严重下降。
    线程池的种类
      newFixedThreadPool        固定大小
      newSingleThreadExecutor   单个线程
      newCachedThreadPool       创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。
      newScheduledThreadPool    创建一个定长线程池，支持定时及周期性任务执行。
21.hashmap和concurrenthashmap基本原理
22.hashmap死循环
23.一致性hash

24.为什么wait()、notify()和notifyAll()方法不是Thread类声明中的方法，而是Object类中声明的方法
       由于每个对象都拥有monitor（即锁），所以让当前线程等待某个对象的锁，当然应该通过这个对象来操作了。
25.jvm中程序计数器的使用
       每一个线程都会在启动时创建一个程序计数器，大小是一个字长，可以存放每一条字节码的地址。如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。
26.Java基本数据类型和长度
    byte（字节型）     1     -128～127 
    short（短整型）    2     -32768～32767 
    int（整型）        4     -2147483648～2147483647 
    long（长整型）     8     -9223372036854775808 ~ 9223372036854775807 
    float（浮点型）    4     -3.4E38～3.4E38 
    double（双精度型） 8     -1.7E308～1.7E308 
    char（字符型）     2     从字符型对应的整型数来划分，其表示范围是0～65535 
    boolean（布尔型）  1bit  true或false     
    void           
27.jvm栈中静态方法调用时在其局部变量表中没有this，非静态方法调用在其局部变量表中第一行就是this而且栈中的数据可以共享基本数据类型可以直    接共享
   局部变量表
   操作数栈
   动态连接   每个栈帧都包含一个指向运行时常量池中该栈帧所属性方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。
              (静态链接：在Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用，这种转化称为静态解析)
              在每一次的运行期期间转化为直接引用，这部分称为动态连接。
   方法返回地址   方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。调用者PC计数器的值就可以作为返回地址。
28.Java中synchronized是在对象头设置标记，Lock 接口的实现类基本上都只是某一个 volitile 修饰的 int 型变量其保证每个线程都能拥有对该int值的可见性和原子修改
         对象头：分代年龄  偏向标志  锁标志位  对象hashcode   线程id  Epoch
         synchronized是通过：monitor去实现锁的机制  JVM要保证monitorentry和monitorexit都是成对出现的
                             锁的4中状态：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态（级别从低到高）
                             偏向锁到轻量级锁
                             线程2来竞争锁对象;
                                 1.判断当前对象头是否是偏向锁;
                                 2.判断拥有偏向锁的线程1是否还存在;
                                 3.线程1不存在,直接设置偏向锁标识为0(线程1执行完毕后,不会主动去释放偏向锁);
                                 4.使用cas替换偏向锁线程ID为线程2,锁不升级，仍为偏向锁;
                                 5.线程1仍然存在,暂停线程1；
                                 6.设置锁标志位为00(变为轻量级锁),偏向锁为0;
                                 7.从线程1的空闲monitor record中读取一条,放至线程1的当前monitor record中;
                                 8.更新mark word，将mark word指向线程1中monitor record的指针;会产生一个指向栈的指针
                                 9.继续执行线程1的代码;
                                 10.锁升级为轻量级锁;   
                                 11.线程2自旋来获取锁对象;
                            偏向锁、轻量级、重量级锁分别解决了三个问题，只有一个线程进入临界区则使用偏向锁，多个线程交替进入临界区则使用轻量级锁，多线程同时进入临界区就要使用重量级锁
29.重写与重载
      重写：子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写。
            重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。
            重写的访问权限不能比父类中被重写的方法的访问权限更低。
            声明为final、static的方法不能被重写。
            构造方法不能被重写。
            子类中调用父类的被重写方法时，要使用super关键字。
            静态分派
      重载：是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。
            重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表
            可以改变访问修饰符
            被重载的方法可以声明新的或更广的检查异常
            无法以返回值类型作为重载函数的区分标准
            动态分派，类在方法区建立一个虚方法表，存放各个方法的实际入口地址。
      重载是一个类的多态性表现,写是子类与父类的一种多态性表现。
30.synchronized与lock的性能比较
31.Java中的四种引用
      强引用：一个对象具有强引用，那垃圾回收器绝不会回收它。当内存不足时，会抛出错误
      软引用：如果内存空间足够，垃圾回收器就不会回收它，如果内存 空间不足了，就会回收这些对象的内存。
      弱引用：具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。
      虚引用：虚引用并不会决定对象的生命周期，如果一个对象 仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。
      后三者可以通过引用对象来判断该对象是否存将要被垃圾回收
32.内部类
      嵌套类  静态（static）内部类。1. 要创建嵌套类的对象，并不需要其外围类的对象。 2. 不能从嵌套类的对象中访问非静态的外围类对象。
      匿名内部类  匿名的内部类不能extends（继承）其它类，但一个内部类可以作为一个接口，由另一个内部类实现。
设计模式
1.工厂模式
2.工厂方法
3.抽象工厂
4.为什么静态单例对象？
   单例模式唯一的实例必须为静态。不能创建对象，只能通过类中的接口来调用类中创建的对象。 使用类名直接调用类中的方法，所以类中的成员函数和数据成员必须是静态的。
5.单例模式中的多线程问题如何解决 
   懒汉模式：加同步锁，双重检测锁定、静态内部类（类似恶汉模式）。 
6.观察者模式
7.如何破坏单例 反射机制和序列化机制 

Mysql数据库
1.数据库索引
   唯一索引 索引值唯一，但允许有空值 
   主键索引 特殊的唯一索引，但不允许有空值 
   普通索引 除去主索引、唯一索引的索引。
   组合索引 多个属性值构成的索引
   辅助索引 辅助索引是相对于主键索引而言的。在MyISAM中，辅助索引的结构和主码索引的结构是一样的，都是采用的是B树结构，且叶子节点存储的 
            都是数据记录的地址。而InnoDB中虽然也采用的是Ｂ＋树存储，但是辅助索引的叶子节点存储的是对应于主键。也就是说如果你通过辅助索引查找数据，要先在Ｂ＋树中查找到主键，然后根据主索引查找到对应的记录，查找两次。
2.聚集索引&非聚集索引
   聚集索引 索引键值的逻辑顺序决定了数据的物理储存顺序 叶子节点就是数据块  每个表只能有一个聚集索引 数据行本身只能按一个顺序存储
   非聚集索引 索引键值的逻辑顺序与数据的物理顺序可能不一致 叶子结点是指向对应数据块的指针 
4.索引限制的问题：
   1.使用不等于操作符(<>, !=)
   2.使用 is null 或 is not null    解决：建表时把需要索引的列定义为非空(not null)
   3.使用函数
   4.复合索引左前缀原则 
   5.在JOIN操作中（需要从多个数据表提取数据时），MYSQL只有在主键和外键的数据类型相同时才能使用索引，否则即使建立了索引也不会使用
   6.索引字段进行计算
   7. like语句并非不走索引，仅当通配符“% _”这两个任何一个出现在表达式的第一位时，索引失效。
3.B+树  B树  平衡二叉树 
   B+数 所有关键字出现在叶子节点 非叶节点是索引，叶子节点是 储存 更适合做文件索引系统 查找性能接近二分查找树
   B树  B树和平衡二叉树稍有不同的是B树属于多叉树又名平衡多路查找树（查找路径不只两个）
   平衡二叉树  基于二分法的策略提高数据的查找速度的二叉树的数据结构
4.hash表和B+树的优势 **数据库索引**
   1、唯一索引hash占明显优势。
   2、范围查找B+树占明显优势。
   3、B+树查找速度不会有太大波动。
5.左右连接，内链接，外链接
   内连接：
   左连接：左表为基准 左表全显示  
   右连接：右表为基准 右表全显示
   全链接：full join 全部显示 若没有则显示null
   交叉连接：所有行组合。交叉联接也称作笛卡尔积。
6.数据库事务的隔离级别
   读未提交     脏读  不可重复读 幻读
   读已提交     不可重复读  幻读
   可重复读     幻读
   序列化       正确
   脏读：T1读到T2已改但未提交的数据
   不可重复读：T1事务未结束时，由于T2的修改导致T1事务的前后读取不一致(主要是update)
   幻读：T1事务未结束时，由于T2的修改导致T1事务的前后读取不一致(主要是insert)
7.锁的类型（排他锁、共享锁） 
   排他锁（X锁）：只允许加锁一方读取和修改数据其它不能加任何类型的锁。
   共享锁（S锁）：加锁一方和其它的只能读，其它只能加S锁。
8.failover
9.sql优化：
   1.最左前缀匹配原则   在创建多列索引时，where子句中使用最频繁的一列放在最左边。
   2.尽量选择区分度高的列作为索引
   3.尽量的扩展索引，不要新建索引
   通过explain与慢查询日志对一条sql语句进行优化
9.索引失效条件，什么时候该建立索引
10.视图：mysql的视图不是一种物化视图，它相当于一个虚拟表，本身并不存储数据，当sql在操作视图时所有数据都是从其他表中查出来的。
       1.视图能简化用户操作
       2.视图使用户能以多种角度看待同一数据(个人感觉就是视图背后的sql语句的区别)
       3.视图能够对机密数据提供安全保护(对不同的用户定义不同的视图，使机密数据不出现在不应该看到这些数据的用户视图上)
11.MySQL的主从复制：
     MySQL数据库的每次更新变化都会以“events”的方式记录到一个二进制的log文件，从库可以配置从主库中读取这些log文件，并在从库的本地执行，这样便可以把主库的数据同步到从库。


Redis数据库
1.redis是基于内存的存储结构
2.Redis的数据结构
      String    SDS  {len  free  buff[]}
      Hash      字典Hashmap 链地址法  zipList
      List      listNode(双端链表)
      Set       字典  hashmap / 整数
      SortSet   跳表
3.跳表：
4.redis分布式锁:
  分布式锁一般有三种实现方式：1. 数据库乐观锁；2. 基于Redis的分布式锁；3. 基于ZooKeeper的分布式锁。
5.Redis 集群
6.Redis如何一次取多个数据
    mget GETALL           
7.Redis持久化
    RDB：一个特定的间隔保存那个时间点的一个数据快照、它保存了 Redis 在某个时间点上的数据集。会丢失两个savepoint之间的数据
    AOF：持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。只进行追加操作的日志文件，每秒           fsync 一次将日志文件刷新到磁盘中
    RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快
8.Redis是用”单线程-多路复用IO模型”来实现高性能的内存数据
    单线程避免了上下文的切换和开销
    多路复用IO模型：select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/
                   O事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流。
linux 
1. linux系统中的常用命令
   cd,
   gcc,
   ls(文件列表),
   grep(命令用于查找文件里符合条件的字符串),
   cp(拷贝所有文件),
   find,mv(移动文件),
   rm(删除),
   ps（查看某一时刻进程的运行结果)，
   tar(打包)，
   time（测算一个命令的执行时间）
2.查看CPU的使用情况 top
3.查看内存使用情况：free -f
4.查看硬盘使用情况：df -h

网络基础
1.http协议（请求方式get和post的区别，不同的状态码，URL规格，404是什么错误）
	get:请求读取，post:请求添加信息，
	1xx: 通知信息，2xx：成功，3xx:重定向，4xx：客户端出错，5xx:服务器出错
	<协议>://<主机域名>:<端口号>/<具体路径>
2.cookie,session是什么？
   cookie记录访问网页的情况。Cookie保存在客户端，session保存在服务器端。
3.nat协议
   网络层协议：网络地址转换，将本地IP地址转换为全球IP地址，使专用网内部的主机与因特网上的主机通信。
4.arp协议 
   数据链路层：地址解析协议（由IP地址获得MA地址），在本局域网内广播发送请求，响应数据帧是单波发送。
5.ip地址和mac地址的区别 
   ip地址:网络层地址，包含网络号和主机号，点分十进制表示IPv4 32位,IPv6 128位。 mac地址：物理地址，适配器地址,数据链路层的地址。
6.Http https
8.Https的具体工作原理
7.Tcp udp区别

9.什么是cdn，有什么用
   内容分发网络
   使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。
10.访问网页的过程，具体

网络IO模型
1.阻塞、非阻塞、同步、异步
    阻塞I\O：进程一直等着
    非阻塞I\O:需要不断的询问，进程需要的资源准备好了没
    IO多路复用：当你的某个socket可读或者可写的时候，它可以给你一个通知，事件驱动。如select、poll、epoll 
    异步：直接返回 可以执行其他线程 
2.IO与NIO的区别
    IO       NIO
    面向流	 面向缓冲
    阻塞IO	 非阻塞IO
    无	     选择器
3.NIO：
    块 I/O，块 I/O 的效率可以比流 I/O 高许多。
    I/O 库(在 java.io.*中) 与 NIO 最重要的区别是数据打包和传输的方式。
    通道 和 缓冲区 是 NIO 中的核心对象
    通道是对原 I/O 包中的流的模拟。到任何目的地(或来自任何地方)的所有数据都必须通过一个 Channel 对象。一个 Buffer 实质上是一个容器对象。发送给一个通道的所有对象都必须首先放到缓冲区中；同样地，从通道中读取的任何数据都要读到缓冲区中。
    缓冲区实质上是一个数组。（ByteBuffer）一个 ByteBuffer 可以在其底层字节数组上进行 get/set 操作
    Channel是一个对象，可以通过它读取和写入数据。不会将字节直接写入通道中，而是通过buffer
    通道与流的不同之处在于通道是双向的（流：inputsteam，outputsteam） 通道 可以用于读、写或者同时用于读写
    缓冲区组件：状态变量和访问方法
	    缓冲区在任意时刻的状态：
	            position： position 变量跟踪已经写了多少数据。(读取数据时) 变量跟踪已经写了多少数据。(写入数据时)
	            Limit：limit 变量表明还有多少数据需要取出(在从缓冲区写入通道时)，或者还有多少空间可以放入数据(在从通道读入缓冲区时)。
	            Capacity：缓冲区的 capacity 表明可以储存在缓冲区中的最大数据容量。
	    在将数据写入到输出通道中时 需要调用flip()方法
	            它将 limit 设置为当前 position。
	            它将 position 设置为 0。
	    调用缓冲区的 clear()
	            它将 limit 设置为与 capacity 相同。
	            它设置 position 为 0。
	    缓冲区的使用：一个内部循环
	    缓冲区分片：slice()方法根据现有的缓冲区创建一种子缓冲区。也就是说，它创建一个新的缓冲区，新缓冲区与原来的缓冲区的一部分共享数据
                    窗口的起始和结束位置通过设置 position 和 limit 值来指定，然后调用 Buffer 的 slice()方法.可以通过子缓冲区去处理一些区间内的数据
        只读缓冲区：与原缓冲区完全相同的缓冲区 asReadOnlyBuffer()。注意：不能将只读的缓冲区转换为可写的缓冲区
        Selector（选择器）： Java NIO 中能够检测一到多个 NIO 通道。一个单独的线程可以管理多个 channel，从而管理多个网络连接。
                             与 Selector 一起使用时，Channel 必须处于非阻塞模式下。这意味着不能将 FileChannel 与 Selector 一起使用，因为 FileChannel 不能切换到非阻塞模式。而套接字通道都可以。
4.select poll epoll 区别
        select，poll，epoll都是IO多路复用的机制。I\O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写
        就绪），能够通知程序进行相应的读写操作。

5.CAP理论
     一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）
     可用性（A）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）
     分区容忍性（P）：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就                  当前操作在C和A之间做出选择。