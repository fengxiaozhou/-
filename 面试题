面试题
操作系统
1.线程和进程的区别 	
    进程：并发执行的程序在执行过程中分配和管理资源的基本单位.进程的执行过程是线性的，进程的切换保护资源。 
    线程： 是CPU调度的基本单位 线程共享进程中的资源，线程的切换并不影响计算机软硬件资源的分配。
2.中断和异常的区别
    中断：系统停止当前正在运行的程序而转向其他服务 
    异常：软件运行过程中的一种开发过程中没有考虑到的程序错误也称为同步中断，在指令执行结束后发生的中断 
3.虚拟内存和虚拟地址
	虚拟内存: 程序使用的内存，利用外存来扩充内存，需要内存映射 
	虚拟地址：由页号和偏移量组成，位数与地址总线的位数相同 
4.死锁
   必要条件： 
   （1）互斥条件：一个资源每次只能被一个进程使用 
   （2）请求与保持条件：进程因请求资源而阻塞时，对获得的资源保持不放 
   （3）不剥夺条件：已获得资源，未使用完之前不能被剥夺 
   （4）循环等待条件： 
   解决方法： 
   （1）死锁预防：破坏死锁产生的条件 
   （2）死锁避免：每次申请之前判断是否安全（银行家算法） 
   （3）死锁检测：（超时法和等待图法） 
   （4）死锁解除
5.多进程和多线程 
    前者开销大，后者开销小（数据，资源角度），前者更加独立。 
6.页面置换算法 FIFO，LRU,LFU
    OPT:选择在内存中离下次访问时间最长的页面，将其置换
    FIFO：链表形式存储，先进先出，Belady现象(有时会出现分配的物理页面数增加，缺页率反而提高的异常现象)。
    LRU(Least Recently Used)：最近最久没有使用，LRU算法需要记录各个页面使用时间的先后顺序，开销较大。
           如果内存当中的所有页面都未曾访问过，那么LRU算法就退化为FIFO算法。
    LFU(Least Frequently Used：最不常用算法。
        LRU考察的是多久未访问，时间越短越好；而LFU考察的是访问的次数或频率，访问次数越多越好。
7.抖动问题
    刚被置换出的页面马上又被使用。随着驻留内存的进程数目增加，分配给每个进程的物理页面数不断减小，缺页率不断上升，系统中多道程序度过高，进程运行缺页率严重。
8.缺页中断 
    访问的页不在主存，需要操作系统将其调入主存后再进行访问。
9.进程间通信的方式
    管道
       普通管道：半双工,只能单向传输;只能在父子进程间使用
       命名管道：可以在许多并不相关的进程之间进行通讯
       流式管道：可以双向传输
    消息队列
        消息队列是由消息的链表，存放在内核中并由消息队列标识符标识 
        消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点
    信号量  
        信号量是一个计数器，常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段
    socket  
        可以在不同机器之间进行通信
    共享内存
        映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问
    信号
10.线程间的通信方式
    临界区
    事件
    互斥量
    信号量
11.线程状态，具体怎么运行的
    新建(new)         新创建了一个线程对象。
    可运行(runnable)  可运行线程池中，等待被线程调度选中，获取cpu 的使用权。
    运行(running)     可运行状态(runnable)的线程获得了cpu 时间片（timeslice） ，执行程序代码。
    阻塞(block)       指线程因为某种原因放弃了cpu 使用权,暂时停止运行,直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice 
                      转到运行(running)状态。
                      有三种阻塞：等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。
                                  同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(
                                            lock pool)中。
                                  其他阻塞：运行(running)的线程执行Thread.sleep或t.join方法，或者发出了I/O请求时，JVM会把该线程置
                                            为阻塞状态。
    死亡(dead)：      线程run()、main() 方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。

算法
1.10亿个数找10个频率最高的（top K问题）
2.1001里两个重复的数字（重复数字问题）
3.二叉树层次遍历（如何只遍历某一层）
4.链表反转
5.二叉树遍历，递归和非递归
6.常用排序算法（复杂度，稳定性）
7.找出数组中最大的连续和 (动态规划)
8.合并两个有序链表
9.快速排序算法（手写） 递归&非递归
10.2sum和ksum问题 
11.蓄水池问题
12.实现大数相乘
13.重建二叉树
14.字符串全排列
15.0，1背包
16.找最长回文
17.层次打印二叉树


java基础
1.AQS（如何管理线程，实现公平锁和非公平锁）


2.volitile关键字，内存屏障和重排序
3.分布式session三种实现方式和优缺点
4.jvm基本调优参数
    堆设置
	-Xms:初始堆大小
	-Xmx:最大堆大小
	-XX:Xmn:设置年轻代大小
	-XX:NewRatio=n:设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4
	-XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5
	-XX:MaxPermSize=n:设置持久代大小
	-Xss:栈大小
	收集器设置
    -XX:+UseSerialGC:设置串行收集器
    -XX:+UseParallelGC:设置并行收集器
    -XX:+UseParalledlOldGC:设置并行年老代收集器
    -XX:+UseConcMarkSweepGC:设置并发收集器
    垃圾回收统计信息
    -XX:+PrintGC
    -XX:+PrintGCDetails
    -XX:+PrintGCTimeStamps
    并行收集器设置
    -XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数。
    -XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间
    -XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)
    并发收集器设置
    -XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。
    -XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。
    通常情况下  -Xms和-Xmx设置成一样的 是因为当Heap不够用时，会发生内存抖动，影响程序运行稳定性。
5.NIO：
    块 I/O，块 I/O 的效率可以比流 I/O 高许多。
    I/O 库(在 java.io.*中) 与 NIO 最重要的区别是数据打包和传输的方式。
    通道 和 缓冲区 是 NIO 中的核心对象
    通道是对原 I/O 包中的流的模拟。到任何目的地(或来自任何地方)的所有数据都必须通过一个 Channel 对象。一个 Buffer 实质上是一个容器对象。发送给一个通道的所有对象都必须首先放到缓冲区中；同样地，从通道中读取的任何数据都要读到缓冲区中。
    缓冲区实质上是一个数组。（ByteBuffer）一个 ByteBuffer 可以在其底层字节数组上进行 get/set 操作
    Channel是一个对象，可以通过它读取和写入数据。不会将字节直接写入通道中，而是通过buffer
    通道与流的不同之处在于通道是双向的（流：inputsteam，outputsteam） 通道 可以用于读、写或者同时用于读写
    缓冲区组件：状态变量和访问方法
	    缓冲区在任意时刻的状态：
	            position： position 变量跟踪已经写了多少数据。(读取数据时) 变量跟踪已经写了多少数据。(写入数据时)
	            Limit：limit 变量表明还有多少数据需要取出(在从缓冲区写入通道时)，或者还有多少空间可以放入数据(在从通道读入缓冲区时)。
	            Capacity：缓冲区的 capacity 表明可以储存在缓冲区中的最大数据容量。
	    在将数据写入到输出通道中时 需要调用flip()方法
	            它将 limit 设置为当前 position。
	            它将 position 设置为 0。
	    调用缓冲区的 clear()
	            它将 limit 设置为与 capacity 相同。
	            它设置 position 为 0。
	    缓冲区的使用：一个内部循环
	    缓冲区分片：slice()方法根据现有的缓冲区创建一种子缓冲区。也就是说，它创建一个新的缓冲区，新缓冲区与原来的缓冲区的一部分共享数据
                    窗口的起始和结束位置通过设置 position 和 limit 值来指定，然后调用 Buffer 的 slice()方法.可以通过子缓冲区去处理一些区间内的数据
        只读缓冲区：与原缓冲区完全相同的缓冲区 asReadOnlyBuffer()。注意：不能将只读的缓冲区转换为可写的缓冲区
6.GC，垃圾回收算法
7.什么时候垃圾回收
8.hashcode和equals的联系
9.JVM中的直接引用和符号引用
      解析阶段即是虚拟机将常量池内的符号引用替换为直接引用
      符号引用:无歧义的定位到目标  CONSTANT_Class_info常量的表示
      直接引用：1.直接指向目标的指针 2.相对偏移量 3.一个能间接定位到目标的句柄
10.JVM类加载过程
      加载、验证、准备、解析、初始化、使用和卸载7个阶段
11.Java基本数据类型，及占用的空间
12.泛型，定义成员方法和静态方法，接收泛型的参数
13.可检查异常和不可检查异常
14.解决Hash冲突的几种方法
      1.开放地址发  冲突之后向后找一个空的槽位添加
      2.拉链法
      3.再散列      当发生冲突时，使用第二个、第三个、哈希函数计算地址，直到无冲突时。
15.java动态代理
16.Spring，ioc，aop
17.Java向上转型和向下转型
18.线程池的拒绝策略
      AbortPolicy         -- 当任务添加到线程池中被拒绝时，它将抛出 RejectedExecutionException 异常。
	  CallerRunsPolicy    -- 当任务添加到线程池中被拒绝时，会在线程池当前正在运行的Thread线程池中处理被拒绝的任务。
	  DiscardOldestPolicy -- 当任务添加到线程池中被拒绝时，线程池会放弃等待队列中最旧的未处理任务，然后将被拒绝的任务添加到等待队列中。
	  DiscardPolicy       -- 当任务添加到线程池中被拒绝时，线程池将丢弃被拒绝的任务。
	  默认的处理策略是  AbortPolicy
	  以上的策略都实现了RejectedExecutionHandler接口，通过该接口可以自定义拒绝策略
19.线程池参数，执行过程
      corePoolSize：核心线程数 会一直存活  设置allowCoreThreadTimeout=true（默认false）时，核心线程会超时关闭
      maxPoolSize： 最大线程数
      keepAliveTime：线程空闲时间，超过空闲时间可以把核心线程数以外的线程杀死
      unit：等待时间的单位
      workQueue：任务队列，被提交但尚未执行的任务。阻塞队列
      threadFactory:线程工厂，用于创建线程。
      handler：拒绝策略。
      当核心线程池未满时，创建新的线程(即使有空闲的线程)。核心池满的时候，加入等待队列。等待队列满时，创建新的线程。当线程数=maxPoolSiz
      e，且任务队列已满时，线程池会拒绝处理任务而抛出异常。
20.线程池队列的类型
      直接提交队列：SynchronousQueue  没有容量  提交一个执行一个。因此需要很大的maxPoolSize，不然容易执行拒绝策略
      有界队列：ArrayBlockingQueue    参数为最大容量。   FIFO
      无界队列：LinkedBlockingQueue   会一直进入等待队列  线程数不会再增加了(没有外包员工)  FIFO
      优先任务队列：PriorityBlockingQueue   优先级先后顺序
21.hashmap和concurrenthashmap基本原理
22.hashmap死循环
23.一致性hash
24.select poll epoll 区别
25.为什么wait()、notify()和notifyAll()方法不是Thread类声明中的方法，而是Object类中声明的方法
       由于每个对象都拥有monitor（即锁），所以让当前线程等待某个对象的锁，当然应该通过这个对象来操作了。
设计模式
1.工厂模式
2.工厂方法
3.抽象工厂
4.为什么静态单例对象？
   单例模式唯一的实例必须为静态。不能创建对象，只能通过类中的接口来调用类中创建的对象。 使用类名直接调用类中的方法，所以类中的成员函数和数据成员必须是静态的。
5.单例模式中的多线程问题如何解决 
   懒汉模式：加同步锁，双重检测锁定、静态内部类（类似恶汉模式）。 
6.观察者模式
7.如何破坏单例 反射机制和序列化机制 

Mysql数据库
1.数据库索引
   唯一索引 索引值唯一，但允许有空值 
   主键索引 特殊的唯一索引，但不允许有空值 
   普通索引 
   组合索引 多个属性值构成的索引 
2.聚集索引&非聚集索引
   聚集索引 索引键值的逻辑顺序决定了数据的物理储存顺序 叶子节点就是数据块  每个表只能有一个聚集索引 数据行本身只能按一个顺序存储
   非聚集索引 索引键值的逻辑顺序与数据的物理顺序可能不一致 叶子结点是指向对应数据块的指针 
3.B+树  B树  平衡二叉树 
   B+数 所有关键字出现在叶子节点 非叶节点是索引，叶子节点是 储存 更适合做文件索引系统 查找性能接近二分查找树
   B树  B树和平衡二叉树稍有不同的是B树属于多叉树又名平衡多路查找树（查找路径不只两个）
   平衡二叉树  基于二分法的策略提高数据的查找速度的二叉树的数据结构
4.hash表和B+树的优势 **数据库索引**
   1、唯一索引hash占明显优势。
   2、范围查找B+树占明显优势。
   3、B+树查找速度不会有太大波动。
5.左右连接，内链接 内链接
6.数据库事务的隔离级别
7.锁的类型（排他锁、共享锁） 
   排他锁（X锁）：只允许加锁一方读取和修改数据其它不能加任何类型的锁。
   共享锁（S锁）：加锁一方和其它的只能读，其它只能加S锁。
8.failover
9.索引失效条件，什么时候该建立索引

Redis数据库
1.redis基于内存
2.Redis的数据结构
      String    SDS  {len  free  buff[]}
      Hash      字典Hashmap 链地址法  zipList
      List      listNode(双端链表)
      Set       字典  hashmap / 整数
      SortSet   跳表
3.跳表：
4.redis分布式锁:

linux 
1. linux系统中的常用命令
   cd,
   gcc,
   ls(文件列表),
   grep,
   cp(拷贝所有文件),
   find,mv(移动文件),
   rm(删除),
   ps（查看某一时刻进程的运行结果)，
   tar(打包)，
   time（测算一个命令的执行时间）
2.查看CPU的使用情况 top

网络基础
1.http协议（请求方式get和post的区别，不同的状态码，URL规格，404是什么错误）
	get:请求读取，post:请求添加信息，
	1xx: 通知信息，2xx：成功，3xx:重定向，4xx：客户端出错，5xx:服务器出错
	<协议>://<主机域名>:<端口号>/<具体路径>
2.cookie,session是什么？
   cookie记录访问网页的情况。Cookie保存在客户端，session保存在服务器端。
3.nat协议
   网络层协议：网络地址转换，将本地IP地址转换为全球IP地址，使专用网内部的主机与因特网上的主机通信。
4.arp协议 
   数据链路层：地址解析协议（由IP地址获得MA地址），在本局域网内广播发送请求，响应数据帧是单波发送。
5.ip地址和mac地址的区别 
   ip地址:网络层地址，包含网络号和主机号，点分十进制表示IPv4 32位,IPv6 128位。 mac地址：物理地址，适配器地址,数据链路层的地址。
6.Http https
8.Https的具体工作原理
7.Tcp udp区别
9.什么是cdn，有什么用
10.访问网页的过程，具体